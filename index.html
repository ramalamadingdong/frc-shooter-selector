<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>FRC 2026 Shooter Tuning Tool</title>
    <script src="https://cdn.plot.ly/plotly-latest.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            background: #0d1117;
            min-height: 100vh;
            padding: 20px;
            color: #e6edf3;
        }
        .container {
            max-width: 1400px;
            margin: 0 auto;
        }
        .header {
            background: #161b22;
            padding: 30px;
            border-radius: 10px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.4);
            margin-bottom: 20px;
            text-align: center;
            border: 1px solid #30363d;
        }
        .header h1 {
            color: #e6edf3;
            margin-bottom: 10px;
        }
        .header p {
            color: #8b949e;
        }
        .system-info {
            background: #161b22;
            padding: 25px;
            border-radius: 10px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.4);
            margin-bottom: 20px;
            border: 1px solid #30363d;
        }
        .system-info h2 {
            color: #e6edf3;
            margin-bottom: 15px;
            font-size: 20px;
        }
        .system-info p {
            color: #8b949e;
            line-height: 1.6;
            margin-bottom: 10px;
        }
        .system-info ul {
            color: #8b949e;
            margin-left: 20px;
            margin-bottom: 10px;
            line-height: 1.8;
        }
        .system-info li {
            margin-bottom: 5px;
        }
        .system-info .highlight {
            color: #58a6ff;
            font-weight: 600;
        }
        .main-content {
            display: grid;
            grid-template-columns: 400px 1fr;
            gap: 20px;
        }
        .config-panel {
            background: #161b22;
            padding: 25px;
            border-radius: 10px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.4);
            height: fit-content;
            position: sticky;
            top: 20px;
            border: 1px solid #30363d;
        }
        .results-panel {
            background: #161b22;
            padding: 25px;
            border-radius: 10px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.4);
            min-height: 600px;
            border: 1px solid #30363d;
        }
        .form-group {
            margin-bottom: 20px;
        }
        .form-group label {
            display: block;
            margin-bottom: 8px;
            font-weight: 600;
            color: #e6edf3;
            font-size: 14px;
        }
        .form-group select,
        .form-group input {
            width: 100%;
            padding: 10px;
            border: 2px solid #30363d;
            border-radius: 5px;
            font-size: 14px;
            transition: border-color 0.3s;
            background: #0d1117;
            color: #e6edf3;
        }
        .form-group select:focus,
        .form-group input:focus {
            outline: none;
            border-color: #58a6ff;
        }
        .form-group small {
            display: block;
            margin-top: 5px;
            color: #8b949e;
            font-size: 12px;
        }
        .btn {
            background: linear-gradient(135deg, #238636 0%, #2ea043 100%);
            color: white;
            border: none;
            padding: 15px 30px;
            border-radius: 5px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            width: 100%;
            transition: transform 0.2s, box-shadow 0.2s;
        }
        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(46, 160, 67, 0.4);
        }
        .btn:active {
            transform: translateY(0);
        }
        .btn:disabled {
            opacity: 0.6;
            cursor: not-allowed;
        }
        .loading {
            text-align: center;
            padding: 40px;
            color: #8b949e;
        }
        .results-section {
            margin-bottom: 30px;
        }
        .results-section h2 {
            color: #e6edf3;
            margin-bottom: 15px;
            padding-bottom: 10px;
            border-bottom: 2px solid #30363d;
        }
        .metric-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin-bottom: 20px;
        }
        .metric-card {
            background: #21262d;
            padding: 15px;
            border-radius: 8px;
            border-left: 4px solid #58a6ff;
            position: relative;
            cursor: help;
        }
        .metric-card .label {
            font-size: 12px;
            color: #8b949e;
            text-transform: uppercase;
            margin-bottom: 5px;
            display: flex;
            align-items: center;
            gap: 5px;
        }
        .metric-card .label::after {
            content: '?';
            display: inline-flex;
            align-items: center;
            justify-content: center;
            width: 14px;
            height: 14px;
            border-radius: 50%;
            background: #484f58;
            color: #8b949e;
            font-size: 10px;
            font-weight: bold;
        }
        .metric-card:hover .label::after {
            background: #58a6ff;
            color: white;
        }
        .metric-card .value {
            font-size: 24px;
            font-weight: 700;
            color: #e6edf3;
        }
        .metric-card .tooltip {
            visibility: hidden;
            opacity: 0;
            position: absolute;
            bottom: 100%;
            left: 50%;
            transform: translateX(-50%);
            background: #30363d;
            color: #e6edf3;
            padding: 10px 12px;
            border-radius: 6px;
            font-size: 12px;
            font-weight: 400;
            line-height: 1.4;
            width: 220px;
            text-align: left;
            z-index: 100;
            margin-bottom: 8px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.5);
            transition: opacity 0.2s, visibility 0.2s;
        }
        .metric-card .tooltip::after {
            content: '';
            position: absolute;
            top: 100%;
            left: 50%;
            transform: translateX(-50%);
            border: 8px solid transparent;
            border-top-color: #30363d;
        }
        .metric-card:hover .tooltip {
            visibility: visible;
            opacity: 1;
        }
        .status-icon {
            display: inline-block;
            margin-left: 10px;
            font-weight: bold;
        }
        .status-ok { color: #3fb950; }
        .status-warn { color: #d29922; }
        .status-error { color: #f85149; }
        .table-container {
            overflow-x: auto;
            margin-top: 15px;
        }
        table {
            width: 100%;
            border-collapse: collapse;
        }
        th, td {
            padding: 12px;
            text-align: left;
            border-bottom: 1px solid #30363d;
            color: #e6edf3;
        }
        th {
            background: #21262d;
            font-weight: 600;
            color: #e6edf3;
        }
        td {
            background: #161b22;
        }
        tr:hover td {
            background: #21262d;
        }
        .chart-container {
            margin-top: 20px;
            height: 400px;
        }
        .recommendations {
            background: #2d2a1d;
            border-left: 4px solid #d29922;
            padding: 15px;
            border-radius: 5px;
            margin-top: 20px;
        }
        .recommendations h3 {
            margin-bottom: 10px;
            color: #d29922;
        }
        .recommendations ul {
            margin-left: 20px;
            color: #e3b341;
        }
        .recommendations li {
            margin-bottom: 5px;
        }
        .error {
            background: #2d1b1b;
            border-left: 4px solid #f85149;
            padding: 15px;
            border-radius: 5px;
            color: #f85149;
        }
        .code-block {
            background: #0d1117;
            padding: 15px;
            border-radius: 5px;
            overflow-x: auto;
            border: 1px solid #30363d;
        }
        .code-block code {
            color: #79c0ff;
            font-family: 'Consolas', 'Monaco', 'Courier New', monospace;
            font-size: 14px;
            line-height: 1.5;
        }
        .slip-estimator-card {
            background: #21262d;
            border: 1px solid #30363d;
            border-radius: 8px;
            margin-bottom: 20px;
            overflow: hidden;
        }
        .slip-estimator-toggle {
            width: 100%;
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 14px 18px;
            background: transparent;
            border: none;
            cursor: pointer;
            color: #e6edf3;
            font-size: 16px;
            font-weight: 600;
            text-align: left;
            transition: background 0.2s;
        }
        .slip-estimator-toggle:hover {
            background: #30363d;
        }
        .slip-estimator-chevron {
            display: inline-block;
            width: 0;
            height: 0;
            margin-left: 8px;
            border-left: 5px solid transparent;
            border-right: 5px solid transparent;
            border-top: 6px solid #8b949e;
            transition: transform 0.2s;
        }
        .slip-estimator-toggle[aria-expanded="true"] .slip-estimator-chevron {
            transform: rotate(180deg);
        }
        .slip-estimator-body {
            padding: 0 18px 18px 18px;
        }
        .slip-estimator-body[hidden] {
            display: none;
        }
        .slip-estimator-title { color: inherit; }
        .slip-estimator-desc {
            color: #8b949e;
            font-size: 13px;
            margin-bottom: 14px;
            margin-top: 0;
            line-height: 1.5;
        }
        .slip-estimator-card .form-group { margin-bottom: 14px; }
        .slip-estimator-card input[readonly] {
            background: #0d1117;
            color: #8b949e;
            cursor: default;
        }
        .optional { color: #6e7681; font-weight: 400; font-size: 12px; }
        .btn-secondary {
            background: linear-gradient(135deg, #21262d 0%, #30363d 100%);
            color: #e6edf3;
            border: 1px solid #484f58;
            margin-bottom: 12px;
        }
        .btn-secondary:hover {
            background: linear-gradient(135deg, #30363d 0%, #484f58 100%);
            box-shadow: 0 5px 15px rgba(0,0,0,0.3);
        }
        .slip-estimate-result {
            margin-top: 14px;
            padding-top: 14px;
            border-top: 1px solid #30363d;
        }
        .slip-estimate-metrics {
            display: flex;
            flex-wrap: wrap;
            gap: 12px;
            margin-bottom: 12px;
        }
        .slip-metric {
            background: #0d1117;
            padding: 10px 14px;
            border-radius: 6px;
            border: 1px solid #30363d;
        }
        .slip-metric-main { border-left: 4px solid #58a6ff; }
        .slip-metric-label {
            display: block;
            font-size: 11px;
            color: #8b949e;
            text-transform: uppercase;
            margin-bottom: 4px;
        }
        .slip-metric-value { font-size: 18px; font-weight: 700; color: #e6edf3; }
        .btn-use-estimate {
            background: linear-gradient(135deg, #1f6feb 0%, #388bfd 100%);
            padding: 10px 20px;
            font-size: 14px;
        }
        .btn-use-estimate:hover {
            box-shadow: 0 5px 15px rgba(56, 139, 253, 0.4);
        }
        .slip-estimate-error { margin-top: 10px; }
        @media (max-width: 1024px) {
            .main-content {
                grid-template-columns: 1fr;
            }
            .config-panel {
                position: static;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>FRC 2026 Shooter Tuning Tool</h1>
            <p>Interactive tool for optimizing shooter parameters with real-time feedback</p>
        </div>
        
        <div class="system-info">
            <h2>System Overview</h2>
            <p>
                This tool analyzes a <span class="highlight">two-wheel shooter system</span> commonly used in FRC robotics competitions. 
                The system consists of:
            </p>
            <ul>
                <li><strong>Two sides/axes</strong> - The shooter has two independent sides (left and right), each with its own wheel assembly</li>
                <li><strong>Wheels per side</strong> - Each side can have one or more wheels mounted on the same axis (typically 1-2 wheels per side)</li>
                <li><strong>Motors per side</strong> - Each side is driven by one or more motors connected in parallel to share the load</li>
                <li><strong>Flywheel assembly</strong> - Each wheel assembly has a flywheel attached to store rotational energy and maintain consistent ball exit velocity</li>
                <li><strong>Gear reduction</strong> - Motors are connected to the wheel axis through a gearbox to optimize torque and speed</li>
                <li><strong>Ball compression</strong> - The ball is compressed between the two counter-rotating sides, creating friction that transfers energy</li>
            </ul>
            <p>
                <strong>System Architecture:</strong> In a typical two-wheel shooter, you have two sides (left and right) that rotate in opposite 
                directions. Each side consists of a wheel assembly mounted on a common axis. The wheel assembly can have one wheel (single wheel 
                per side) or multiple wheels stacked together (dual/triple wheel configuration). All wheels on the same side rotate together 
                at the same RPM, driven by one or more motors connected through a gearbox. The flywheel is typically attached to the same axis 
                as the wheels to store rotational energy.
            </p>
            <p>
                <strong>How it works:</strong> The ball is fed between the two counter-rotating sides. As the wheels spin, they compress 
                the ball and transfer rotational energy through friction. The ball exits at a velocity determined by the wheel surface speed 
                and compression characteristics. Each side operates independently with its own motor(s), gearbox, and flywheel, allowing for 
                precise control of exit velocity.
            </p>
            <p>
                <strong>Analysis:</strong> This tool calculates optimal shooter angles, required wheel RPMs for different distances (8-20 feet), 
                and evaluates system performance metrics including spin-up time, speed consistency, and motor headroom. The analysis accounts 
                for air drag, ball compression/slip between sides, and flywheel energy storage effects. All motor and gear ratio specifications 
                are per-side (each side has its own motor configuration). The number of wheels per side affects the total moment of inertia 
                (MOI) of the flywheel assembly.
            </p>
        </div>
        
        <div class="main-content">
            <div class="config-panel">
                <h2 style="margin-bottom: 20px; color: #e6edf3;">Configuration</h2>
                <form id="configForm">
                    <div class="form-group">
                        <label for="motor">Motor Type</label>
                        <select id="motor" name="motor"></select>
                    </div>
                    
                    <div class="form-group">
                        <label for="wheels_per_side">Wheels per Side</label>
                        <input type="number" id="wheels_per_side" name="wheels_per_side" value="1" min="1" max="3">
                        <small>Number of wheels mounted on each side/axis (1 = single wheel, 2+ = stacked wheels)</small>
                    </div>
                    
                    <div class="form-group">
                        <label for="motor_num_motors">Motors per Side</label>
                        <input type="number" id="motor_num_motors" name="motor_num_motors" value="2" min="1" max="4">
                        <small>Number of motors driving each side (motors are connected in parallel on the same axis)</small>
                    </div>
                    
                    <div class="form-group">
                        <label for="motor_current_limit">Current Limit (A)</label>
                        <input type="number" id="motor_current_limit" name="motor_current_limit" value="40" step="1" min="10" max="100">
                        <small>Maximum current per motor to prevent overheating</small>
                    </div>
                    
                    <div class="form-group">
                        <label for="gear_ratio">Gear Ratio</label>
                        <input type="number" id="gear_ratio" name="gear_ratio" value="2.0" step="0.1" min="0.1" max="10.0">
                        <small>Motor speed reduction ratio (higher = more torque, lower wheel RPM)</small>
                    </div>
                    
                    <div class="form-group">
                        <label for="flywheel">Flywheel Configuration</label>
                        <select id="flywheel" name="flywheel"></select>
                        <small>Flywheel mass affects energy storage and speed consistency</small>
                    </div>
                    
                    <div class="form-group" id="custom_moi_group" style="display: none;">
                        <label for="custom_moi">Custom MOI (lb-in²)</label>
                        <input type="number" id="custom_moi" name="custom_moi" value="10.0" step="0.1" min="1" max="50">
                        <small>Moment of inertia of your custom flywheel assembly</small>
                    </div>
                    
                    <div class="form-group">
                        <label for="selected_angle">Shooter Angle (deg)</label>
                        <input type="number" id="selected_angle" name="selected_angle" step="1" min="50" max="75" placeholder="Optimal">
                        <small>Launch angle of shooter mechanism (leave empty to find optimal)</small>
                    </div>
                    
                    <div class="form-group">
                        <label for="idle_speed">Idle Speed (RPM)</label>
                        <input type="number" id="idle_speed" name="idle_speed" value="500" step="10" min="0" max="3000">
                        <small>Wheel RPM when shooter is idle (reduces spin-up time)</small>
                    </div>
                    
                    <div class="form-group">
                        <label for="drag_coefficient">Drag Coefficient</label>
                        <input type="number" id="drag_coefficient" name="drag_coefficient" value="0.50" step="0.01" min="0.3" max="0.7">
                        <small>Air resistance coefficient (foam ball typically ~0.5)</small>
                    </div>
                    
                    <div class="form-group">
                        <label for="ball_incoming_velocity">Ball Incoming Velocity (m/s)</label>
                        <input type="number" id="ball_incoming_velocity" name="ball_incoming_velocity" value="0" step="0.1" min="0" max="10">
                        <small>Velocity of the ball before entering the shooter (from feeding mechanism). Reduces the velocity the wheels need to add.</small>
                    </div>
                    
                    <div class="slip-estimator-card">
                        <button type="button" class="slip-estimator-toggle" id="slipEstimatorToggle" aria-expanded="false" aria-controls="slipEstimatorBody">
                            <span class="slip-estimator-title">Estimate Slip/Compression Factor</span>
                            <span class="slip-estimator-chevron" aria-hidden="true"></span>
                        </button>
                        <div id="slipEstimatorBody" class="slip-estimator-body" hidden>
                        <p class="slip-estimator-desc">Use center-to-center distance and wheel type to get a suggested slip factor. Surface gap = center-to-center minus wheel diameter; compression = 5.9 in (ball) minus that gap.</p>
                        <div class="form-group">
                            <label for="center_to_center">Distance between wheel centers (in)</label>
                            <input type="number" id="center_to_center" step="0.01" min="4" max="11" placeholder="e.g. 9.4" value="">
                            <small>Center-to-center distance between the two wheel axes. Surface gap = center-to-center minus wheel diameter (from wheel type below).</small>
                        </div>
                        <div class="form-group">
                            <label>Wheel diameter</label>
                            <input type="text" id="estimator_wheel_diameter_display" readonly placeholder="Select wheel type below">
                            <small>Uses the Wheel Type / Wheel Diameter from this form. Circumference = pi × diameter.</small>
                        </div>
                        <div class="form-group">
                            <label for="estimator_wheel_width">Wheel width (in) <span class="optional">optional</span></label>
                            <input type="number" id="estimator_wheel_width" step="0.1" min="0.5" max="3" placeholder="1.0">
                            <small>Optional refinement; contact area is hard to estimate because wheels and ball are curved.</small>
                        </div>
                        <div class="form-group">
                            <label for="estimator_contact_area">Contact surface area (in²) <span class="optional">optional</span></label>
                            <input type="number" id="estimator_contact_area" step="0.1" min="0" max="20" placeholder="e.g. 4">
                            <small>With constant-curvature wheels and a round ball, actual contact is hard to measure; the main estimate uses center-to-center and entry speed.</small>
                        </div>
                        <div class="form-group">
                            <label>Ball incoming velocity</label>
                            <input type="text" id="estimator_entry_speed_display" readonly placeholder="Uses value from form">
                            <small>Uses the Ball Incoming Velocity (m/s) from this form when you click Estimate.</small>
                        </div>
                        <button type="button" class="btn btn-secondary" id="estimateSlipBtn">Estimate</button>
                        <div id="slip_estimate_result" class="slip-estimate-result" style="display: none;">
                            <div class="slip-estimate-metrics">
                                <div class="slip-metric"><span class="slip-metric-label">Surface gap</span><span id="result_gap" class="slip-metric-value"></span> in</div>
                                <div class="slip-metric"><span class="slip-metric-label">Compression</span><span id="result_compression" class="slip-metric-value"></span> in</div>
                                <div class="slip-metric"><span class="slip-metric-label">Wheel circumference</span><span id="result_circumference" class="slip-metric-value"></span> in</div>
                                <div class="slip-metric slip-metric-main"><span class="slip-metric-label">Estimated slip factor</span><span id="result_slip_factor" class="slip-metric-value"></span></div>
                            </div>
                            <button type="button" class="btn btn-use-estimate" id="useEstimateBtn">Use this value</button>
                        </div>
                        <div id="slip_estimate_error" class="error slip-estimate-error" style="display: none;"></div>
                        </div>
                    </div>
                    
                    <div class="form-group">
                        <label for="slip_factor">Slip/Compression Factor</label>
                        <input type="number" id="slip_factor" name="slip_factor" value="1.15" step="0.01" min="1.0" max="1.3">
                        <small>
                            Ratio of wheel surface speed to ball exit velocity. Accounts for ball compression (ball deforms when squeezed, reducing effective contact radius) and slip between ball and wheels. 
                            Formula: wheel_surface_speed = ball_exit_velocity × slip_factor. 
                            Typical values: 1.0 = no slip/compression (ideal), 1.10-1.20 = typical for foam balls, 1.15 = recommended default.
                        </small>
                    </div>
                    
                    <div class="form-group">
                        <label for="wheel_type">Wheel Type</label>
                        <select id="wheel_type" name="wheel_type"></select>
                        <small>Select wheel type - diameter and MOI will be set automatically</small>
                    </div>
                    
                    <div class="form-group" id="custom_wheel_moi_group" style="display: none;">
                        <label for="custom_wheel_moi">Custom Wheel MOI (lb-in²)</label>
                        <input type="number" id="custom_wheel_moi" name="custom_wheel_moi" value="0.9" step="0.1" min="0.1" max="5.0">
                        <small>Moment of inertia for your custom wheel</small>
                    </div>
                    
                    <div class="form-group">
                        <label for="wheel_diameter">Wheel Diameter (inches)</label>
                        <input type="number" id="wheel_diameter" name="wheel_diameter" value="4.0" step="0.1" min="2.0" max="8.0">
                        <small>Diameter of the shooter wheels (auto-updated when wheel type is selected)</small>
                    </div>
                    
                    <div class="form-group">
                        <label for="motor_efficiency">Motor Efficiency</label>
                        <input type="number" id="motor_efficiency" name="motor_efficiency" value="0.85" step="0.01" min="0.5" max="1.0">
                        <small>Mechanical efficiency of motor and gearbox (typically 0.80-0.90)</small>
                    </div>
                    
                    <button type="submit" class="btn" id="analyzeBtn">Run Analysis</button>
                </form>
            </div>
            
            <div class="results-panel" id="resultsPanel">
                <div class="loading" id="loading" style="display: none;">
                    <p>Running analysis...</p>
                </div>
                <div id="resultsContent"></div>
            </div>
        </div>
    </div>
    
    <script>
        // Physics constants
        const G = 9.81; // m/s^2
        const BALL_DIAMETER_M = 5.9 * 0.0254;
        const BALL_RADIUS_M = BALL_DIAMETER_M / 2;
        const BALL_MASS_KG = 0.5 * 0.453592;
        const BALL_CROSS_SECTION = Math.PI * BALL_RADIUS_M ** 2;
        const AIR_DENSITY = 1.2; // kg/m^3
        const RIM_HEIGHT_M = 72 * 0.0254;
        const EXIT_HEIGHT_M = 20 * 0.0254;
        const DELTA_Y = RIM_HEIGHT_M - EXIT_HEIGHT_M;
        const DISTANCES_FT = [8, 10, 12, 14, 16, 18, 20];
        const DISTANCES_M = DISTANCES_FT.map(d => d * 0.3048);
        const BALL_DIAMETER_IN = 5.9;

        function estimateSlipFactor(centerToCenterIn, wheelDiamIn, wheelWidthIn, contactAreaIn2, ballIncomingMs) {
            const gap = Math.max(0.1, Math.min(centerToCenterIn - wheelDiamIn, BALL_DIAMETER_IN - 0.1));
            const compressionIn = BALL_DIAMETER_IN - gap;
            const wheelCircumferenceIn = Math.PI * wheelDiamIn;
            let slip = 1.0 + 0.18 * compressionIn;
            slip += 0.008 * Math.max(0, ballIncomingMs);
            if (contactAreaIn2 != null && contactAreaIn2 > 0) {
                const areaFactor = Math.min(8, contactAreaIn2);
                slip -= 0.004 * (areaFactor - 3);
            }
            if (wheelWidthIn != null && wheelWidthIn > 0 && (contactAreaIn2 == null || contactAreaIn2 <= 0)) {
                const rBall = BALL_DIAMETER_IN / 2;
                const chord = 2 * Math.sqrt(Math.max(0, rBall * rBall - Math.pow(rBall - compressionIn / 2, 2)));
                const estimatedArea = 2 * wheelWidthIn * chord;
                if (estimatedArea > 0) slip -= 0.004 * (Math.min(8, estimatedArea) - 3);
            }
            slip = Math.max(1.0, Math.min(1.3, slip));
            return {
                compression_in: Math.round(compressionIn * 1000) / 1000,
                wheel_circumference_in: Math.round(wheelCircumferenceIn * 1000) / 1000,
                estimated_slip_factor: Math.round(slip * 1000) / 1000,
                gap_between_wheels_in: Math.round(gap * 1000) / 1000
            };
        }

        // Presets
        const MOTOR_PRESETS = {
            '1': {name: 'Kraken X44', free_speed_rpm: 7530, stall_torque_nm: 4.05, peak_torque_nm: 2.0, stall_current_a: 275, default_current_limit: 40},
            '2': {name: 'Kraken X60', free_speed_rpm: 5800, stall_torque_nm: 9.37, peak_torque_nm: 4.7, stall_current_a: 483, default_current_limit: 60},
            '3': {name: 'Falcon 500', free_speed_rpm: 6380, stall_torque_nm: 4.69, peak_torque_nm: 2.35, stall_current_a: 257, default_current_limit: 40},
            '4': {name: 'NEO', free_speed_rpm: 5676, stall_torque_nm: 2.6, peak_torque_nm: 1.3, stall_current_a: 105, default_current_limit: 40},
            '5': {name: 'NEO Vortex', free_speed_rpm: 6784, stall_torque_nm: 3.6, peak_torque_nm: 1.8, stall_current_a: 211, default_current_limit: 40},
        };

        const FLYWHEEL_PRESETS = {
            '1': {name: 'None (wheels only)', moi_lb_in2: 0.0},
            '2': {name: 'WCP Single Flywheel', moi_lb_in2: 2.7},
            '3': {name: 'WCP Dual Flywheels', moi_lb_in2: 5.4},
            '4': {name: 'WCP + Dual Stealth (Recommended)', moi_lb_in2: 14.76},
            '5': {name: 'Heavy Flywheel Setup', moi_lb_in2: 8.0},
            '6': {name: 'Custom Flywheel MOI', moi_lb_in2: null},
        };

        const WHEEL_PRESETS = {
            '1': {name: '4" Thrifty Bot Urethane (45A)', moi_lb_in2: 0.9, diameter_in: 4.0},
            '2': {name: '4" Stealth Wheel', moi_lb_in2: 0.9, diameter_in: 4.0},
            '3': {name: '3" Stealth Wheel', moi_lb_in2: 0.5, diameter_in: 3.0},
            '4': {name: '5" Stealth Wheel', moi_lb_in2: 1.4, diameter_in: 5.0},
            '5': {name: '2" Stealth Wheel', moi_lb_in2: 0.25, diameter_in: 2.0},
            '6': {name: '4" Compliance Wheel', moi_lb_in2: 0.6, diameter_in: 4.0},
            '7': {name: '3" Compliance Wheel', moi_lb_in2: 0.35, diameter_in: 3.0},
            '8': {name: '2" Compliance Wheel', moi_lb_in2: 0.2, diameter_in: 2.0},
            '9': {name: '4" Colson Wheel', moi_lb_in2: 1.3, diameter_in: 4.0},
            '10': {name: '3" Colson Wheel', moi_lb_in2: 0.7, diameter_in: 3.0},
            '11': {name: '4" REV ION Traction', moi_lb_in2: 0.85, diameter_in: 4.0},
            '12': {name: '3" REV ION Traction', moi_lb_in2: 0.48, diameter_in: 3.0},
            '13': {name: '2" REV ION Traction', moi_lb_in2: 0.22, diameter_in: 2.0},
            '14': {name: '4" REV ION Compliant (Soft 30A)', moi_lb_in2: 0.55, diameter_in: 4.0},
            '15': {name: '4" REV ION Compliant (Medium 40A)', moi_lb_in2: 0.65, diameter_in: 4.0},
            '16': {name: '4" REV ION Compliant (Hard 60A)', moi_lb_in2: 0.75, diameter_in: 4.0},
            '17': {name: '3" REV ION Compliant (Soft 30A)', moi_lb_in2: 0.31, diameter_in: 3.0},
            '18': {name: '3" REV ION Compliant (Medium 40A)', moi_lb_in2: 0.37, diameter_in: 3.0},
            '19': {name: '3" REV ION Compliant (Hard 60A)', moi_lb_in2: 0.42, diameter_in: 3.0},
            '20': {name: '4" REV DUO Traction', moi_lb_in2: 0.8, diameter_in: 4.0},
            '21': {name: '3" REV DUO Traction', moi_lb_in2: 0.45, diameter_in: 3.0},
            '22': {name: '4" WCP Traction Wheel', moi_lb_in2: 0.95, diameter_in: 4.0},
            '23': {name: '3" WCP Traction Wheel', moi_lb_in2: 0.53, diameter_in: 3.0},
            '24': {name: 'Custom Wheel', moi_lb_in2: null, diameter_in: null},
        };

        // Initialize dropdowns
        function initDropdowns() {
            const motorSelect = document.getElementById('motor');
            Object.keys(MOTOR_PRESETS).forEach(key => {
                const motor = MOTOR_PRESETS[key];
                const option = document.createElement('option');
                option.value = key;
                option.textContent = `${motor.name} (${motor.free_speed_rpm} RPM)`;
                option.dataset.name = motor.name;
                option.dataset.freeSpeed = motor.free_speed_rpm;
                option.dataset.stallTorque = motor.stall_torque_nm;
                option.dataset.peakTorque = motor.peak_torque_nm;
                option.dataset.stallCurrent = motor.stall_current_a;
                option.dataset.currentLimit = motor.default_current_limit;
                motorSelect.appendChild(option);
            });

            const flywheelSelect = document.getElementById('flywheel');
            Object.keys(FLYWHEEL_PRESETS).forEach(key => {
                const fw = FLYWHEEL_PRESETS[key];
                const option = document.createElement('option');
                option.value = key;
                option.textContent = fw.moi_lb_in2 !== null ? `${fw.name} (${fw.moi_lb_in2} lb-in²)` : fw.name;
                option.dataset.moi = fw.moi_lb_in2 !== null ? fw.moi_lb_in2 : '';
                option.dataset.name = fw.name;
                if (key === '4') option.selected = true;
                flywheelSelect.appendChild(option);
            });

            const wheelSelect = document.getElementById('wheel_type');
            Object.keys(WHEEL_PRESETS).forEach(key => {
                const wheel = WHEEL_PRESETS[key];
                const option = document.createElement('option');
                option.value = key;
                option.textContent = wheel.moi_lb_in2 !== null ? `${wheel.name} (${wheel.moi_lb_in2} lb-in²)` : wheel.name;
                option.dataset.moi = wheel.moi_lb_in2 !== null ? wheel.moi_lb_in2 : '';
                option.dataset.diameter = wheel.diameter_in !== null ? wheel.diameter_in : '';
                if (key === '1') option.selected = true;
                wheelSelect.appendChild(option);
            });
        }

        // Physics calculations (converted from Python)
        function calculateTotalMOI(config) {
            let flywheelMOI = config.flywheel_moi_lb_in2;
            let wheelMOI = config.wheel_moi_lb_in2;
            
            if (wheelMOI === null || wheelMOI === undefined) {
                const wheelType = config.wheel_type || '1';
                if (WHEEL_PRESETS[wheelType] && WHEEL_PRESETS[wheelType].moi_lb_in2 !== null) {
                    wheelMOI = WHEEL_PRESETS[wheelType].moi_lb_in2;
                } else {
                    wheelMOI = 0.225 * config.wheel_diameter_in ** 2;
                }
            }
            
            const wheelsPerSide = config.wheels_per_side || 1;
            const totalWheelMOI = wheelMOI * wheelsPerSide * 2;
            const totalMOI_lb_in2 = flywheelMOI + totalWheelMOI;
            const totalMOI_kg_m2 = totalMOI_lb_in2 / (1 / 0.453592 / (0.0254 ** 2));
            
            return [totalMOI_lb_in2, totalMOI_kg_m2];
        }

        function simulateTrajectory(v0, angleDeg, dragCoeff, dt = 0.002) {
            const dragConstant = 0.5 * AIR_DENSITY * dragCoeff * BALL_CROSS_SECTION;
            const theta = angleDeg * Math.PI / 180;
            let x = 0, y = 0;
            let vx = v0 * Math.cos(theta), vy = v0 * Math.sin(theta);
            const xs = [], ys = [], vxs = [], vys = [];
            let t = 0;
            const maxTime = 5.0;
            const sampleInterval = 0.02;
            let nextSample = sampleInterval;
            let adaptiveDt = dt;

            while (t < maxTime && y >= -EXIT_HEIGHT_M && x < 30) {
                const v = Math.sqrt(vx ** 2 + vy ** 2);
                let ax, ay;
                if (v > 0) {
                    const aDrag = dragConstant * v ** 2 / BALL_MASS_KG;
                    ax = -aDrag * vx / v;
                    ay = -G - aDrag * vy / v;
                } else {
                    ax = 0;
                    ay = -G;
                }

                if (Math.abs(y - DELTA_Y) < 0.5) {
                    adaptiveDt = dt * 0.5;
                } else {
                    adaptiveDt = dt;
                }

                vx += ax * adaptiveDt;
                vy += ay * adaptiveDt;
                x += vx * adaptiveDt;
                y += vy * adaptiveDt;
                t += adaptiveDt;

                if (t >= nextSample) {
                    xs.push(x);
                    ys.push(y);
                    vxs.push(vx);
                    vys.push(vy);
                    nextSample += sampleInterval;
                }
            }

            return {x: xs, y: ys, vx: vxs, vy: vys};
        }

        function findRimCrossing(traj) {
            const xs = traj.x, ys = traj.y, vxs = traj.vx, vys = traj.vy;
            for (let i = 1; i < ys.length; i++) {
                if (ys[i-1] >= DELTA_Y && ys[i] < DELTA_Y && vys[i] < 0) {
                    const frac = (DELTA_Y - ys[i-1]) / (ys[i] - ys[i-1]);
                    const xCross = xs[i-1] + frac * (xs[i] - xs[i-1]);
                    const vyCross = vys[i-1] + frac * (vys[i] - vys[i-1]);
                    const vxCross = vxs[i-1] + frac * (vxs[i] - vxs[i-1]);
                    const entryAngle = Math.atan2(vyCross, vxCross) * 180 / Math.PI;
                    return [xCross, vyCross, entryAngle, true];
                }
            }
            return [Infinity, 0, 0, false];
        }

        function findRequiredVelocity(targetM, angleDeg, dragCoeff) {
            let vLow = 1.0, vHigh = 50.0;
            const tolerance = 0.05;
            let bestV = null, bestTraj = null, bestError = Infinity;

            for (let iteration = 0; iteration < 20; iteration++) {
                const vMid = (vLow + vHigh) / 2;
                const traj = simulateTrajectory(vMid, angleDeg, dragCoeff);
                const [xLand, , , valid] = findRimCrossing(traj);

                if (!valid) {
                    vLow = vMid;
                    continue;
                }

                const error = Math.abs(xLand - targetM);
                if (error < bestError) {
                    bestError = error;
                    bestV = vMid;
                    bestTraj = traj;
                }

                if (error < tolerance) {
                    return [vMid, traj];
                } else if (xLand < targetM) {
                    vLow = vMid;
                } else {
                    vHigh = vMid;
                }

                if (vHigh - vLow < 0.05) break;
            }

            return [bestV || (vLow + vHigh) / 2, bestTraj || simulateTrajectory((vLow + vHigh) / 2, angleDeg, dragCoeff)];
        }

        function calcSensitivity(angleDeg, v0, dragCoeff) {
            const deltaV = 0.1, deltaA = 0.5;
            const trajPlusV = simulateTrajectory(v0 + deltaV, angleDeg, dragCoeff);
            const trajMinusV = simulateTrajectory(v0 - deltaV, angleDeg, dragCoeff);
            const trajPlusA = simulateTrajectory(v0, angleDeg + deltaA, dragCoeff);
            const trajMinusA = simulateTrajectory(v0, angleDeg - deltaA, dragCoeff);

            const [xPlusV] = findRimCrossing(trajPlusV);
            const [xMinusV] = findRimCrossing(trajMinusV);
            const [xPlusA] = findRimCrossing(trajPlusA);
            const [xMinusA] = findRimCrossing(trajMinusA);

            const dxdv = (xPlusV !== Infinity && xMinusV !== Infinity) ? Math.abs((xPlusV - xMinusV) / (2 * deltaV)) : 10.0;
            const dxda = (xPlusA !== Infinity && xMinusA !== Infinity) ? Math.abs((xPlusA - xMinusA) / (2 * deltaA)) : 10.0;
            return [dxdv, dxda];
        }

        function calcSpeedDrop(initialRpm, exitVelMs, moiKgM2, efficiency = 0.70, ballIncomingMs = 0) {
            const omegaInitial = initialRpm * 2 * Math.PI / 60;
            const EFlywheel = 0.5 * moiKgM2 * omegaInitial ** 2;
            const EBall = 0.5 * BALL_MASS_KG * (exitVelMs ** 2 - ballIncomingMs ** 2);
            const ETaken = EBall / efficiency;
            const ENew = Math.max(0, EFlywheel - ETaken);
            const omegaFinal = ENew > 0 ? Math.sqrt(2 * ENew / moiKgM2) : 0;
            return omegaInitial > 0 ? ((omegaInitial - omegaFinal) / omegaInitial) * 100 : 100;
        }

        function calcRpmAfterShot(initialRpm, exitVelMs, moiKgM2, efficiency = 0.70, ballIncomingMs = 0) {
            const omegaInitial = initialRpm * 2 * Math.PI / 60;
            const EFlywheel = 0.5 * moiKgM2 * omegaInitial ** 2;
            const EBall = 0.5 * BALL_MASS_KG * (exitVelMs ** 2 - ballIncomingMs ** 2);
            const ETaken = EBall / efficiency;
            const ENew = Math.max(0, EFlywheel - ETaken);
            const omegaFinal = ENew > 0 ? Math.sqrt(2 * ENew / moiKgM2) : 0;
            return (omegaFinal * 60) / (2 * Math.PI);
        }

        function calcSpinupTime(targetRpm, gearRatio, moiKgM2, idleRpm, config) {
            const freeSpeedRads = config.motor_free_speed_rpm * 2 * Math.PI / 60;
            const kt = config.motor_stall_torque_nm / config.motor_stall_current_a;
            const torqueAtLimit = config.motor_current_limit_a * kt;
            const usableTorque = Math.min(config.motor_peak_torque_nm, torqueAtLimit);

            const targetRadS = targetRpm * 2 * Math.PI / 60;
            const motorTargetRadS = targetRadS * gearRatio;
            const JMotor = moiKgM2 / (gearRatio ** 2);

            const dt = 0.002;
            let omega = (idleRpm * 2 * Math.PI / 60) * gearRatio;
            let t = 0;

            while (omega < motorTargetRadS && t < 5) {
                const speedFraction = omega / freeSpeedRads;
                const tauCurve = config.motor_stall_torque_nm * (1 - speedFraction);
                const tauMotor = Math.min(tauCurve, usableTorque);
                const tauTotal = config.motor_num_motors * tauMotor * config.motor_efficiency;
                const alpha = tauTotal / JMotor;
                omega += alpha * dt;
                t += dt;
            }

            return t;
        }

        function calcSpinupTimeFromRpm(targetRpm, startRpm, gearRatio, moiKgM2, config) {
            const freeSpeedRads = config.motor_free_speed_rpm * 2 * Math.PI / 60;
            const kt = config.motor_stall_torque_nm / config.motor_stall_current_a;
            const torqueAtLimit = config.motor_current_limit_a * kt;
            const usableTorque = Math.min(config.motor_peak_torque_nm, torqueAtLimit);

            const targetRadS = targetRpm * 2 * Math.PI / 60;
            const motorTargetRadS = targetRadS * gearRatio;
            const JMotor = moiKgM2 / (gearRatio ** 2);

            const dt = 0.002;
            let omega = (startRpm * 2 * Math.PI / 60) * gearRatio;
            let t = 0;

            while (omega < motorTargetRadS && t < 5) {
                const speedFraction = omega / freeSpeedRads;
                const tauCurve = config.motor_stall_torque_nm * (1 - speedFraction);
                const tauMotor = Math.min(tauCurve, usableTorque);
                const tauTotal = config.motor_num_motors * tauMotor * config.motor_efficiency;
                const alpha = tauTotal / JMotor;
                omega += alpha * dt;
                t += dt;
            }

            return t;
        }

        function runAnalysis(config) {
            const dragCoeff = config.drag_coefficient;
            const slipFactor = config.slip_factor;
            const wheelDiamM = config.wheel_diameter_in * 0.0254;
            const ballIncomingVelocity = config.ball_incoming_velocity_ms != null ? config.ball_incoming_velocity_ms : 0;

            const [moiLbIn2, moiKgM2] = calculateTotalMOI(config);
            const gearRatio = config.gear_ratio;
            const idleRpm = config.idle_speed_rpm;
            const effFreeSpeed = config.motor_free_speed_rpm / gearRatio;

            const angles = [];
            for (let a = 50; a <= 75; a++) angles.push(a);
            const angleResults = [];
            const sensitivityCache = {};

            for (const angle of angles) {
                const velocities = [];
                const entryAngles = [];
                let valid = true;

                for (const distM of DISTANCES_M) {
                    const [v, traj] = findRequiredVelocity(distM, angle, dragCoeff);
                    const [, , entry, ok] = findRimCrossing(traj);
                    if (!ok || v > 40) {
                        valid = false;
                        break;
                    }
                    velocities.push(v);
                    entryAngles.push(entry);
                }

                if (valid) {
                    const vMin = Math.min(...velocities);
                    const vMax = Math.max(...velocities);
                    const vRange = vMax - vMin;
                    const midIdx = Math.floor(DISTANCES_M.length / 2);
                    const midVelocity = velocities[midIdx];

                    const cacheKey = `${angle}_${midVelocity.toFixed(2)}`;
                    let dxdv, dxda;
                    if (sensitivityCache[cacheKey]) {
                        [dxdv, dxda] = sensitivityCache[cacheKey];
                    } else {
                        [dxdv, dxda] = calcSensitivity(angle, midVelocity, dragCoeff);
                        sensitivityCache[cacheKey] = [dxdv, dxda];
                    }

                    const sensVMean = dxdv;
                    const sensAMean = dxda;
                    const score = sensVMean * 2.0 + sensAMean * 1.0 + vRange / 5.0;

                    angleResults.push({
                        angle, velocities, entryAngles,
                        vMin, vMax, vRange,
                        sens_v_mean: sensVMean, sens_a_mean: sensAMean, score
                    });
                }
            }

            if (angleResults.length === 0) {
                return {error: 'No valid angles found'};
            }

            angleResults.sort((a, b) => a.score - b.score);
            const optimal = angleResults[0];

            let selected = optimal;
            if (config.selected_angle !== null && config.selected_angle !== undefined) {
                const selectedList = angleResults.filter(r => r.angle === Math.round(config.selected_angle));
                selected = selectedList.length > 0 ? selectedList[0] : optimal;
            }

            const wheelRpms = {};
            const shotData = {};
            for (let i = 0; i < DISTANCES_FT.length; i++) {
                const distFt = DISTANCES_FT[i];
                const vExit = selected.velocities[i];
                const vWheelContribution = Math.max(0, vExit - ballIncomingVelocity);
                const surfaceSpeed = vWheelContribution * slipFactor;
                const wheelRpm = (surfaceSpeed / (Math.PI * wheelDiamM)) * 60;
                wheelRpms[distFt] = wheelRpm;
                shotData[distFt] = {
                    v_exit_ms: vExit,
                    v_exit_fps: vExit / 0.3048,
                    v_wheel_contribution_ms: vWheelContribution,
                    wheel_rpm: wheelRpm,
                    entry_angle: selected.entryAngles[i]
                };
            }

            const minRpm = Math.min(...Object.values(wheelRpms));
            const maxRpm = Math.max(...Object.values(wheelRpms));
            const headroom = (1 - maxRpm / effFreeSpeed) * 100;

            const speedDrop20 = calcSpeedDrop(wheelRpms[20], shotData[20].v_exit_ms, moiKgM2, 0.70, ballIncomingVelocity);
            const spinup8 = calcSpinupTime(wheelRpms[8], gearRatio, moiKgM2, idleRpm, config) * 1000;
            const spinup20 = calcSpinupTime(wheelRpms[20], gearRatio, moiKgM2, idleRpm, config) * 1000;

            const rpmAfterShot8 = calcRpmAfterShot(wheelRpms[8], shotData[8].v_exit_ms, moiKgM2, 0.70, ballIncomingVelocity);
            const rpmAfterShot20 = calcRpmAfterShot(wheelRpms[20], shotData[20].v_exit_ms, moiKgM2, 0.70, ballIncomingVelocity);
            const spinupBetween8 = calcSpinupTimeFromRpm(wheelRpms[8], rpmAfterShot8, gearRatio, moiKgM2, config) * 1000;
            const spinupBetween20 = calcSpinupTimeFromRpm(wheelRpms[20], rpmAfterShot20, gearRatio, moiKgM2, config) * 1000;

            return {
                optimal_angle: optimal.angle,
                optimal_score: optimal.score,
                selected_angle: selected.angle,
                selected_score: selected.score,
                sens_v_mean: selected.sens_v_mean,
                sens_a_mean: selected.sens_a_mean,
                v_range: selected.v_range,
                min_rpm: minRpm,
                max_rpm: maxRpm,
                headroom: headroom,
                eff_free_speed: effFreeSpeed,
                speed_drop_20: speedDrop20,
                spinup_8_ms: spinup8,
                spinup_20_ms: spinup20,
                spinup_between_8_ms: spinupBetween8,
                spinup_between_20_ms: spinupBetween20,
                total_moi_lb_in2: moiLbIn2,
                ball_incoming_velocity_ms: ballIncomingVelocity,
                wheel_rpms: wheelRpms,
                shot_data: shotData,
                all_angles: angleResults,
            };
        }

        // UI code
        const form = document.getElementById('configForm');
        const resultsContent = document.getElementById('resultsContent');
        const loading = document.getElementById('loading');
        const analyzeBtn = document.getElementById('analyzeBtn');
        const flywheelSelect = document.getElementById('flywheel');
        const customMoiGroup = document.getElementById('custom_moi_group');
        const wheelTypeSelect = document.getElementById('wheel_type');
        const customWheelMoiGroup = document.getElementById('custom_wheel_moi_group');
        const wheelDiameterInput = document.getElementById('wheel_diameter');

        initDropdowns();

        flywheelSelect.addEventListener('change', function() {
            customMoiGroup.style.display = this.value === '6' ? 'block' : 'none';
        });

        wheelTypeSelect.addEventListener('change', function() {
            const selectedOption = this.options[this.selectedIndex];
            const diameter = selectedOption.dataset.diameter;
            const moi = selectedOption.dataset.moi;
            
            if (this.value === '24') {
                customWheelMoiGroup.style.display = 'block';
            } else {
                customWheelMoiGroup.style.display = 'none';
                if (diameter) {
                    wheelDiameterInput.value = diameter;
                }
            }
            updateSlipEstimatorDisplays();
        });

        document.getElementById('ball_incoming_velocity').addEventListener('input', updateSlipEstimatorDisplays);

        function updateSlipEstimatorDisplays() {
            const wheelOpt = wheelTypeSelect.options[wheelTypeSelect.selectedIndex];
            const diameter = wheelOpt.dataset.diameter || wheelDiameterInput.value;
            document.getElementById('estimator_wheel_diameter_display').value = diameter ? diameter + ' in' : '';
            document.getElementById('estimator_entry_speed_display').value = document.getElementById('ball_incoming_velocity').value + ' m/s';
        }

        document.getElementById('slipEstimatorToggle').addEventListener('click', function() {
            const body = document.getElementById('slipEstimatorBody');
            const isOpen = body.hidden;
            body.hidden = !isOpen;
            this.setAttribute('aria-expanded', isOpen ? 'true' : 'false');
        });

        document.getElementById('estimateSlipBtn').addEventListener('click', function() {
            const centerToCenter = parseFloat(document.getElementById('center_to_center').value);
            const wheelDiam = parseFloat(document.getElementById('wheel_diameter').value);
            const ballIncoming = parseFloat(document.getElementById('ball_incoming_velocity').value) || 0;
            const wheelWidthRaw = document.getElementById('estimator_wheel_width').value;
            const contactAreaRaw = document.getElementById('estimator_contact_area').value;
            if (isNaN(wheelDiam) || wheelDiam <= 0) {
                document.getElementById('slip_estimate_error').textContent = 'Select a wheel type below to set diameter.';
                document.getElementById('slip_estimate_error').style.display = 'block';
                document.getElementById('slip_estimate_result').style.display = 'none';
                return;
            }
            const minCc = wheelDiam + 0.1;
            const maxCc = wheelDiam + 5.8;
            if (isNaN(centerToCenter) || centerToCenter < minCc || centerToCenter > maxCc) {
                document.getElementById('slip_estimate_error').textContent = 'Enter a valid center-to-center distance (' + minCc.toFixed(1) + ' to ' + maxCc.toFixed(1) + ' in for ' + wheelDiam + '" wheels).';
                document.getElementById('slip_estimate_error').style.display = 'block';
                document.getElementById('slip_estimate_result').style.display = 'none';
                return;
            }
            document.getElementById('slip_estimate_error').style.display = 'none';
            const wheelWidth = wheelWidthRaw !== '' ? parseFloat(wheelWidthRaw) : null;
            const contactArea = contactAreaRaw !== '' ? parseFloat(contactAreaRaw) : null;
            const data = estimateSlipFactor(centerToCenter, wheelDiam, wheelWidth, contactArea, ballIncoming);
            document.getElementById('result_gap').textContent = data.gap_between_wheels_in;
            document.getElementById('result_compression').textContent = data.compression_in;
            document.getElementById('result_circumference').textContent = data.wheel_circumference_in;
            document.getElementById('result_slip_factor').textContent = data.estimated_slip_factor;
            document.getElementById('slip_estimate_result').style.display = 'block';
            document.getElementById('useEstimateBtn').dataset.estimatedSlip = data.estimated_slip_factor;
        });

        document.getElementById('useEstimateBtn').addEventListener('click', function() {
            const val = this.dataset.estimatedSlip;
            if (val) document.getElementById('slip_factor').value = val;
        });

        updateSlipEstimatorDisplays();

        document.getElementById('motor').addEventListener('change', function() {
            const selectedMotor = this.options[this.selectedIndex];
            document.getElementById('motor_current_limit').value = selectedMotor.dataset.currentLimit;
        });

        form.addEventListener('submit', function(e) {
            e.preventDefault();
            
            const motorSelect = document.getElementById('motor');
            const selectedMotor = motorSelect.options[motorSelect.selectedIndex];
            
            const config = {
                motor_name: selectedMotor.dataset.name,
                motor_free_speed_rpm: parseFloat(selectedMotor.dataset.freeSpeed),
                motor_stall_torque_nm: parseFloat(selectedMotor.dataset.stallTorque),
                motor_peak_torque_nm: parseFloat(selectedMotor.dataset.peakTorque),
                motor_stall_current_a: parseFloat(selectedMotor.dataset.stallCurrent),
                wheels_per_side: parseInt(document.getElementById('wheels_per_side').value),
                motor_num_motors: parseInt(document.getElementById('motor_num_motors').value),
                motor_current_limit_a: parseFloat(document.getElementById('motor_current_limit').value),
                motor_efficiency: parseFloat(document.getElementById('motor_efficiency').value),
                idle_speed_rpm: parseFloat(document.getElementById('idle_speed').value),
                gear_ratio: parseFloat(document.getElementById('gear_ratio').value),
                drag_coefficient: parseFloat(document.getElementById('drag_coefficient').value),
                slip_factor: parseFloat(document.getElementById('slip_factor').value),
                ball_incoming_velocity_ms: parseFloat(document.getElementById('ball_incoming_velocity').value) || 0,
                wheel_diameter_in: parseFloat(document.getElementById('wheel_diameter').value),
            };
            
            const wheelTypeSelect = document.getElementById('wheel_type');
            config.wheel_type = wheelTypeSelect.value;
            if (wheelTypeSelect.value === '24') {
                config.wheel_moi_lb_in2 = parseFloat(document.getElementById('custom_wheel_moi').value);
            } else {
                config.wheel_moi_lb_in2 = null;
            }
            
            const angleInput = document.getElementById('selected_angle').value;
            config.selected_angle = angleInput ? parseFloat(angleInput) : null;
            
            const flywheelSelect = document.getElementById('flywheel');
            const selectedFlywheel = flywheelSelect.options[flywheelSelect.selectedIndex];
            config.flywheel_name = selectedFlywheel.dataset.name;
            
            if (flywheelSelect.value === '6') {
                config.flywheel_moi_lb_in2 = parseFloat(document.getElementById('custom_moi').value);
            } else {
                config.flywheel_moi_lb_in2 = parseFloat(selectedFlywheel.dataset.moi);
            }
            
            loading.style.display = 'block';
            resultsContent.innerHTML = '';
            analyzeBtn.disabled = true;
            
            // Run analysis asynchronously to avoid blocking UI
            setTimeout(() => {
                try {
                    const results = runAnalysis(config);
                    
                    if (results.error) {
                        resultsContent.innerHTML = `<div class="error"><strong>Error:</strong> ${results.error}</div>`;
                    } else {
                        displayResults(config, results);
                    }
                } catch (error) {
                    console.error('Analysis error:', error);
                    resultsContent.innerHTML = `<div class="error"><strong>Error:</strong> ${error.message}<br><small>Check console for details</small></div>`;
                } finally {
                    loading.style.display = 'none';
                    analyzeBtn.disabled = false;
                }
            }, 10);
        });
        
        function statusIcon(value, good, warn, lowerBetter = true) {
            if (lowerBetter) {
                if (value <= good) return '<span class="status-icon status-ok">[OK]</span>';
                if (value <= warn) return '<span class="status-icon status-warn">[!]</span>';
                return '<span class="status-icon status-error">[X]</span>';
            } else {
                if (value >= good) return '<span class="status-icon status-ok">[OK]</span>';
                if (value >= warn) return '<span class="status-icon status-warn">[!]</span>';
                return '<span class="status-icon status-error">[X]</span>';
            }
        }
        
        function displayResults(config, results) {
            if (!config || !results || results.error) {
                resultsContent.innerHTML = `<div class="error">${results.error || 'Missing config or results data'}</div>`;
                return;
            }
            
            if (!results.shot_data || !results.wheel_rpms || !results.all_angles) {
                resultsContent.innerHTML = `<div class="error">Invalid results structure. Missing required fields.</div>`;
                return;
            }
            
            let html = `
                <div class="results-section">
                    <h2>Configuration Summary</h2>
                    <div class="metric-grid">
                        <div class="metric-card">
                            <div class="tooltip">The motor type driving each wheel assembly. Different motors have different free speeds, torque characteristics, and current limits.</div>
                            <div class="label">Motor</div>
                            <div class="value">${config.motor_name}</div>
                        </div>
                        <div class="metric-card">
                            <div class="tooltip">Number of motors connected in parallel driving each side. More motors = more torque and faster spin-up, but higher weight and cost.</div>
                            <div class="label">Motors per Side</div>
                            <div class="value">${config.motor_num_motors}</div>
                        </div>
                        <div class="metric-card">
                            <div class="tooltip">Number of wheels stacked on each side/axis. More wheels increase total moment of inertia and contact area with the ball.</div>
                            <div class="label">Wheels per Side</div>
                            <div class="value">${config.wheels_per_side || 1}</div>
                        </div>
                        <div class="metric-card">
                            <div class="tooltip">Motor-to-wheel gear reduction ratio. Higher ratio = more torque but lower max wheel RPM. Lower ratio = higher speed but less torque.</div>
                            <div class="label">Gear Ratio</div>
                            <div class="value">${config.gear_ratio}:1</div>
                        </div>
                        <div class="metric-card">
                            <div class="tooltip">The flywheel configuration adding rotational mass to each side. More mass = more energy storage and consistent shots, but slower spin-up.</div>
                            <div class="label">Flywheel</div>
                            <div class="value">${config.flywheel_name}</div>
                        </div>
                        <div class="metric-card">
                            <div class="tooltip">Total Moment of Inertia per side (flywheel + wheels). Higher MOI stores more energy for consistent multi-shot accuracy but takes longer to spin up.</div>
                            <div class="label">Total MOI</div>
                            <div class="value">${(results.total_moi_lb_in2 ?? 0).toFixed(1)} lb-in²</div>
                        </div>
                        <div class="metric-card">
                            <div class="tooltip">Ball velocity before entering the shooter (from feeding mechanism). Reduces the velocity the wheels need to add.</div>
                            <div class="label">Ball Incoming Vel</div>
                            <div class="value">${(results.ball_incoming_velocity_ms ?? 0).toFixed(1)} m/s</div>
                        </div>
                    </div>
                </div>
                
                <div class="results-section">
                    <h2>Performance Metrics</h2>
                    <div class="metric-grid">
                        <div class="metric-card">
                            <div class="tooltip">The launch angle of the shooter mechanism. The optimal angle minimizes sensitivity to velocity and angle errors across all distances.</div>
                            <div class="label">Selected Angle</div>
                            <div class="value">${results.selected_angle}° ${results.selected_angle === results.optimal_angle ? '(optimal)' : `(optimal: ${results.optimal_angle}°)`}</div>
                        </div>
                        <div class="metric-card">
                            <div class="tooltip">Combined score measuring shot consistency. Lower is better. Accounts for velocity sensitivity, angle sensitivity, and velocity range needed. Target: &lt;4.0 (good), &lt;6.0 (acceptable).</div>
                            <div class="label">Consistency Score</div>
                            <div class="value">${results.selected_score.toFixed(2)} ${statusIcon(results.selected_score, 4.0, 6.0)}</div>
                        </div>
                        <div class="metric-card">
                            <div class="tooltip">How much the landing position changes per 1 m/s change in exit velocity. Lower means more forgiving of speed errors. Target: &lt;1.0 m/(m/s) (good), &lt;1.5 (acceptable).</div>
                            <div class="label">Velocity Sensitivity</div>
                            <div class="value">${results.sens_v_mean.toFixed(3)} m/(m/s) ${statusIcon(results.sens_v_mean, 1.0, 1.5)}</div>
                        </div>
                        <div class="metric-card">
                            <div class="tooltip">How much the landing position changes per 1 degree change in launch angle. Lower means more forgiving of angle errors. Target: &lt;0.1 m/deg (good), &lt;0.2 (acceptable).</div>
                            <div class="label">Angle Sensitivity</div>
                            <div class="value">${results.sens_a_mean.toFixed(3)} m/deg ${statusIcon(results.sens_a_mean, 0.1, 0.2)}</div>
                        </div>
                        <div class="metric-card">
                            <div class="tooltip">The range of wheel RPMs needed to cover all shooting distances (8-20 ft). A narrower range means simpler control but the absolute values matter for motor selection.</div>
                            <div class="label">RPM Range</div>
                            <div class="value">${results.min_rpm.toFixed(0)} - ${results.max_rpm.toFixed(0)} RPM</div>
                        </div>
                        <div class="metric-card">
                            <div class="tooltip">Percentage of motor free speed remaining above the maximum required RPM. More headroom means faster recovery and margin for error. Target: &gt;30% (good), &gt;10% (minimum).</div>
                            <div class="label">Headroom</div>
                            <div class="value">${results.headroom.toFixed(1)}% ${statusIcon(results.headroom, 30, 10, false)}</div>
                        </div>
                        <div class="metric-card">
                            <div class="tooltip">Percentage of wheel speed lost after launching one ball from 20ft distance. Lower means more consistent multi-shot accuracy. More flywheel mass reduces this. Target: &lt;15% (good), &lt;25% (acceptable).</div>
                            <div class="label">Speed Drop (20ft)</div>
                            <div class="value">${results.speed_drop_20.toFixed(1)}% ${statusIcon(results.speed_drop_20, 15, 25)}</div>
                        </div>
                        <div class="metric-card">
                            <div class="tooltip">Time to spin up from idle speed to the RPM needed for 8ft shots. Affects how quickly you can shoot after acquiring a ball. Target: &lt;300ms (good), &lt;500ms (acceptable).</div>
                            <div class="label">Spin-up (8ft)</div>
                            <div class="value">${results.spinup_8_ms.toFixed(0)} ms ${statusIcon(results.spinup_8_ms, 300, 500)}</div>
                        </div>
                        <div class="metric-card">
                            <div class="tooltip">Time to spin up from idle speed to the RPM needed for 20ft shots. Longer distance requires higher RPM, so spin-up takes longer. Target: &lt;400ms (good), &lt;600ms (acceptable).</div>
                            <div class="label">Spin-up (20ft)</div>
                            <div class="value">${results.spinup_20_ms.toFixed(0)} ms ${statusIcon(results.spinup_20_ms, 400, 600)}</div>
                        </div>
                        <div class="metric-card">
                            <div class="tooltip">Time to spin up from the reduced RPM after shooting an 8ft shot back to the target RPM for the next shot. This affects how quickly you can take consecutive shots. Target: &lt;200ms (good), &lt;400ms (acceptable).</div>
                            <div class="label">Spin-up Between Shots (8ft)</div>
                            <div class="value">${results.spinup_between_8_ms.toFixed(0)} ms ${statusIcon(results.spinup_between_8_ms, 200, 400)}</div>
                        </div>
                        <div class="metric-card">
                            <div class="tooltip">Time to spin up from the reduced RPM after shooting a 20ft shot back to the target RPM for the next shot. Longer shots cause more speed drop, so recovery takes longer. Target: &lt;300ms (good), &lt;500ms (acceptable).</div>
                            <div class="label">Spin-up Between Shots (20ft)</div>
                            <div class="value">${results.spinup_between_20_ms.toFixed(0)} ms ${statusIcon(results.spinup_between_20_ms, 300, 500)}</div>
                        </div>
                    </div>
                </div>
                
                <div class="results-section">
                    <h2>Shot Data Table</h2>
                    <div class="table-container">
                        <table>
                            <thead>
                                <tr>
                                    <th>Distance (ft)</th>
                                    <th>Exit Vel (m/s)</th>
                                    <th>Exit Vel (ft/s)</th>
                                    ${(results.ball_incoming_velocity_ms ?? 0) > 0 ? '<th>Wheel Contrib (m/s)</th>' : ''}
                                    <th>Wheel RPM</th>
                                    <th>Entry Angle (deg)</th>
                                </tr>
                            </thead>
                            <tbody>
            `;
            
            const hasIncomingVel = (results.ball_incoming_velocity_ms ?? 0) > 0;
            DISTANCES_FT.forEach(dist => {
                const shot = results.shot_data[dist];
                const vWheelContrib = shot.v_wheel_contribution_ms != null ? shot.v_wheel_contribution_ms : (shot.v_exit_ms ?? 0);
                html += `
                    <tr>
                        <td>${dist}</td>
                        <td>${(shot.v_exit_ms ?? 0).toFixed(2)}</td>
                        <td>${(shot.v_exit_fps ?? 0).toFixed(1)}</td>
                        ${hasIncomingVel ? `<td>${vWheelContrib.toFixed(2)}</td>` : ''}
                        <td>${(shot.wheel_rpm ?? 0).toFixed(0)}</td>
                        <td>${(shot.entry_angle ?? 0).toFixed(1)}</td>
                    </tr>
                `;
            });
            
            html += `
                            </tbody>
                        </table>
                    </div>
                </div>
                
                <div class="results-section">
                    <h2>RPM Lookup Table (for Robot Code)</h2>
                    <pre class="code-block"><code>// Distance (ft) -> Wheel RPM
const SHOOTER_RPM_TABLE = {
            `;
            
            DISTANCES_FT.forEach(dist => {
                html += `    ${dist}: ${results.wheel_rpms[dist].toFixed(0)},\n`;
            });
            
            html += `};</code></pre>
                </div>
            `;
            
            const recommendations = getRecommendations(config, results);
            if (recommendations.length > 0) {
                html += `
                    <div class="recommendations">
                        <h3>Recommendations</h3>
                        <ul>
                `;
                recommendations.forEach(rec => {
                    html += `<li>${rec}</li>`;
                });
                html += `
                        </ul>
                    </div>
                `;
            }
            
            html += `
                <div class="results-section">
                    <h2>Angle Comparison</h2>
                    <div class="chart-container" id="angleChart"></div>
                </div>
                
                <div class="results-section">
                    <h2>RPM Requirements</h2>
                    <div class="chart-container" id="rpmChart"></div>
                </div>
            `;
            
            resultsContent.innerHTML = html;
            
            createAngleChart(results);
            createRPMChart(config, results);
        }
        
        function getRecommendations(config, results) {
            const recs = [];
            
            if (results.headroom < 10) {
                recs.push('[!] Low headroom - increase gear ratio or use faster motor');
            }
            if (results.headroom < 0) {
                recs.push('[X] CRITICAL: Exceeds motor free speed! Must increase gear ratio');
            }
            
            if (results.speed_drop_20 > 25) {
                recs.push('[!] High speed drop - consider more flywheel mass');
            } else if (results.speed_drop_20 > 15) {
                recs.push('[-] Speed drop slightly high - could add flywheel mass');
            }
            
            if (results.spinup_20_ms > 600) {
                recs.push('[!] Slow spin-up - reduce flywheel mass or increase gear ratio');
            }
            
            if (results.spinup_between_20_ms > 500) {
                recs.push('[!] Slow recovery between shots - consider more motors or less flywheel mass');
            } else if (results.spinup_between_20_ms > 300) {
                recs.push('[-] Recovery between shots slightly slow - could optimize for faster multi-shot');
            }
            
            if (results.selected_angle !== results.optimal_angle) {
                const diff = results.selected_score - results.optimal_score;
                if (diff > 0.5) {
                    recs.push(`[-] Angle ${results.optimal_angle}° has better consistency (score: ${results.optimal_score.toFixed(2)})`);
                }
            }
            
            if (recs.length === 0) {
                recs.push('[OK] Configuration looks good!');
            }
            
            return recs;
        }
        
        function createAngleChart(results) {
            const angles = results.all_angles.map(r => r.angle);
            const scores = results.all_angles.map(r => r.score);
            
            const trace = {
                x: angles,
                y: scores,
                type: 'bar',
                marker: {
                    color: angles.map(a => a === results.optimal_angle ? '#3fb950' : a === results.selected_angle ? '#d29922' : '#58a6ff')
                }
            };
            
            const layout = {
                title: {
                    text: 'Consistency Score by Angle (lower is better)',
                    font: { color: '#e6edf3' }
                },
                xaxis: { 
                    title: 'Shooter Angle (deg)',
                    color: '#8b949e',
                    gridcolor: '#30363d'
                },
                yaxis: { 
                    title: 'Consistency Score',
                    color: '#8b949e',
                    gridcolor: '#30363d'
                },
                showlegend: false,
                paper_bgcolor: '#161b22',
                plot_bgcolor: '#161b22',
                font: { color: '#e6edf3' }
            };
            
            Plotly.newPlot('angleChart', [trace], layout);
        }
        
        function createRPMChart(config, results) {
            const rpms = DISTANCES_FT.map(d => results.wheel_rpms[d]);
            
            const trace = {
                x: DISTANCES_FT,
                y: rpms,
                type: 'bar',
                marker: { color: '#58a6ff' }
            };
            
            const layout = {
                title: {
                    text: `Wheel RPM Requirements (${config.motor_name})`,
                    font: { color: '#e6edf3' }
                },
                xaxis: { 
                    title: 'Distance (ft)',
                    color: '#8b949e',
                    gridcolor: '#30363d'
                },
                yaxis: { 
                    title: 'Required Wheel RPM',
                    color: '#8b949e',
                    gridcolor: '#30363d'
                },
                shapes: [{
                    type: 'line',
                    x0: 0,
                    x1: 1,
                    xref: 'paper',
                    y0: results.eff_free_speed,
                    y1: results.eff_free_speed,
                    yref: 'y',
                    line: { color: '#f85149', width: 2, dash: 'dash' }
                }],
                annotations: [{
                    x: 20,
                    y: results.eff_free_speed,
                    text: `Eff. Free Speed (${results.eff_free_speed.toFixed(0)} RPM)`,
                    showarrow: true,
                    arrowhead: 2,
                    ax: 0,
                    ay: -30,
                    font: { color: '#e6edf3' }
                }],
                showlegend: false,
                paper_bgcolor: '#161b22',
                plot_bgcolor: '#161b22',
                font: { color: '#e6edf3' }
            };
            
            Plotly.newPlot('rpmChart', [trace], layout);
        }
    </script>
</body>
</html>
